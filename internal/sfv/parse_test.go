package sfv

import (
	"strings"
	"testing"
)

func TestParseIgnoresCommentsAndBlanks(t *testing.T) {
	t.Parallel()

	content := `
; generated by test

sample one.mkv 00000000
folder/two.avi 89ABCDEF
`

	entries, err := Parse(strings.NewReader(content))
	if err != nil {
		t.Fatalf("Parse returned error: %v", err)
	}

	if len(entries) != 2 {
		t.Fatalf("Parse returned %d entries, want 2", len(entries))
	}

	if entries[0].Name != "sample one.mkv" || entries[0].CRC != 0x00000000 {
		t.Fatalf("entry[0] = %+v", entries[0])
	}

	if entries[1].Name != "folder/two.avi" || entries[1].CRC != 0x89ABCDEF {
		t.Fatalf("entry[1] = %+v", entries[1])
	}
}

func TestParseSupportsCRLF(t *testing.T) {
	t.Parallel()

	content := "; comment\r\nmovie.mkv A1B2C3D4\r\n"
	entries, err := Parse(strings.NewReader(content))
	if err != nil {
		t.Fatalf("Parse returned error: %v", err)
	}

	if len(entries) != 1 {
		t.Fatalf("Parse returned %d entries, want 1", len(entries))
	}
	if entries[0].Name != "movie.mkv" || entries[0].CRC != 0xA1B2C3D4 {
		t.Fatalf("entry[0] = %+v", entries[0])
	}
}

func TestParseInvalidLine(t *testing.T) {
	t.Parallel()

	content := "missing-crc-value\n"
	if _, err := Parse(strings.NewReader(content)); err == nil {
		t.Fatal("expected parse error for malformed line")
	}
}
